generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("PRISMA_DATABASE_URL")
  directUrl = env("PRISMA_DATABASE_URL")
}

// ============ PERFECT PRISMA SCHEMA - BI-DIRECTIONAL RELATIONS ============
// Following ALL Prisma best practices for production-grade architecture
// Every relation has its exact opposite - no ambiguous naming

model UserPlan {
  id                    String   @id @default(cuid())
  name                  String   @unique
  displayName           String
  price                 Float    @default(0)
  currency              String   @default("NGN")
  maxScansPerMonth      Int      @default(10)
  maxAIRequestsPerMonth Int      @default(10)
  priority              Int      @default(1)
  isActive              Boolean  @default(true)

  // Bidirectional relations - exact matches required
  users                 User[] @relation("PlanToUsers")
  subscriptions         Subscription[] @relation("SubscriptionToPlan") // ✅ Added for bidirectional validation
  planAssignments       PlanAssignment[]

  @@index([isActive, priority])
}

// ============ PERFECT USER MODEL - ALL RELATIONS BI-DIRECTIONAL ============

model User {
  id                String      @id @default(cuid())
  name              String?     @db.VarChar(255)
  email             String      @unique
  emailVerified     DateTime?
  image             String?
  pointsBalance     Int         @default(5)
  dailyPointsLastGiven String   @default("")
  createdAt         DateTime    @default(now())
  updatedAt         DateTime    @updatedAt
  planId            String      @default("free")

  // All bidirectional relations with exact matching names
  planUsers         UserPlan    @relation("PlanToUsers", fields: [planId], references: [id])
  userProductChecks ProductCheck[] @relation("UserProductChecks")
  userCheckResults  CheckResult[] @relation("CheckResultToUser")
  userPayments      Payment[] @relation("UserToPayments")
  userSubscriptions Subscription[] @relation("UserToSubscriptions")
  aiUsageRecords    AIUsageRecord[] @relation("AIUsageToUser") // ✅ Added for bidirectional validation
  accounts           Account[] @relation("AccountToUser")
  userSessions      Session[] @relation("SessionToUser")

  @@index([email])
}

// NOTE: AI Providers, Usage Tracking, and Plan Assignments
// are COMMENTED OUT for quick launch. They work in your services/
// but database relations will be added post-launch when you have revenue

// ============ AI PROVIDER MANAGEMENT ============
// Critical for admin panel AI provider management

model AIProvider {
  id                  String   @id @default(cuid())
  name                String
  provider            String   // "openai", "anthropic", "google", etc.
  modelName           String
  costPerRequest      Float    @default(0.002)
  maxRequestsPerHour  Int      @default(1000)
  maxRequestsPerDay   Int      @default(10000)
  priority            Int      @default(1)
  isActive            Boolean  @default(true)
  createdAt           DateTime @default(now())

  // Many-to-many relation with UserPlan via PlanAssignment
  planAssignments     PlanAssignment[]
  aiUsageRecords      AIUsageRecord[] @relation("AIUsageToProvider") // ✅ Added matching relation

  // Indexes for performance
  @@index([isActive])
  @@index([priority])
}

model PlanAssignment {
  id              String     @id @default(cuid())
  aiProviderId    String
  planId          String
  isActive        Boolean    @default(true)
  maxRequestsPerHour Int     @default(100)  // Plan-specific limits
  priority        Int        @default(1)
  createdAt       DateTime   @default(now())

  // Bidirectional relations
  aiProvider      AIProvider @relation(fields: [aiProviderId], references: [id])
  plan            UserPlan   @relation(fields: [planId], references: [id])

  // Unique constraint - one assignment per provider-plan combination
  @@unique([aiProviderId, planId])
  @@index([isActive])
}

// ============ VERIFICATION MODELS ============

model ProductCheck {
  id                String       @id @default(cuid())
  userId            String
  productName       String       @db.VarChar(500)
  productDescription String      @db.Text
  images            String[]
  batchNumber       String?      // ✅ Added for optimized queries compatibility
  pointsUsed        Int          @default(0)
  createdAt         DateTime     @default(now())

  // Bidirectional relations - exact matches required
  checkUser         User         @relation("UserProductChecks", fields: [userId], references: [id])
  checkResults      CheckResult[] @relation("CheckResultToCheck")

  @@index([userId, createdAt])
}

model CheckResult {
  id                String      @id @default(cuid())
  userId            String
  productCheckId    String
  isCounterfeit     Boolean     @default(false)
  summary           String?
  source            String?     @default("NAFDAC")  // ✅ Added for NAFDAC source tracking
  sourceUrl         String?
  batchNumber       String?
  confidence        Float       @default(0)
  alertType         String?     // ✅ Added for optimized queries
  scrapedAt         DateTime?   // ✅ Added for optimized queries
  createdAt         DateTime    @default(now())

  // Bidirectional relations - exact matches required
  checkUser         User        @relation("CheckResultToUser", fields: [userId], references: [id])
  productCheck      ProductCheck @relation("CheckResultToCheck", fields: [productCheckId], references: [id])

  @@index([isCounterfeit])
}

// ============ EXISTING NAFDAC SYSTEM ============

model NafdacAlert {
  id               String   @id @default(cuid())
  title            String   @db.Text
  url              String   @unique @db.Text
  excerpt          String   @db.Text
  date             String   @db.VarChar(20)
  fullContent      String   @db.Text
  productNames     String[]
  batchNumbers     String[]
  manufacturer     String?
  alertType        String   @db.VarChar(50)
  category         String   @default("recalls")
  severity         String   @db.VarChar(50)
  similarity_score Float    @default(0)  // ✅ Added for optimized query compatibility
  scrapedAt        DateTime @default(now())
  active           Boolean  @default(true)

  // AI enhancements
  aiExtracted     Boolean @default(false)
  aiProductNames  String[]
  aiBatchNumbers  String[]
  aiReason        String?
  aiConfidence    Float   @default(0)

  @@index([active])
  @@index([scrapedAt])
  @@index([batchNumbers])
  @@index([similarity_score])  // ✅ Index for optimized search ordering
}

// ============ AUTH MODELS ============

model Account {
  id               String @id @default(cuid())
  userId           String
  type             String
  provider         String
  providerAccountId String
  refresh_token    String?
  access_token     String?
  expires_at       Int?
  token_type       String?
  scope            String?
  id_token         String?
  session_state    String?

  // ✅ FIXED: Standard NextAuth relation name (adapter expects `user`)
  user User @relation("AccountToUser", fields: [userId], references: [id], onDelete: Cascade)

  // ✅ CRITICAL: Add compound unique constraint required by NextAuth PrismaAdapter
  @@unique([provider, providerAccountId])
  @@index([userId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime

  // Bidirectional relation - exact match required
  sessionUser User @relation("SessionToUser", fields: [userId], references: [id], onDelete: Cascade)
  @@index([sessionToken])
}

// ============ PAYMENT & REVENUE MODELS ============
// Essential for payment processing and revenue tracking

model Payment {
  id                String   @id @default(cuid())
  userId            String
  transactionId     String   @unique
  amount            Float
  currency          String   @default("NGN")
  status            String   @default("pending")
  pointsPurchased   Int?
  paymentGateway    String   @default("paystack")
  gatewayResponse   Json?
  processedAt       DateTime?
  webhookProcessed  Boolean  @default(false)
  createdAt         DateTime @default(now())

  // Bidirectional relation with User
  user              User     @relation("UserToPayments", fields: [userId], references: [id])
}

model ScraperStatus {
  id            String   @id
  isScraping    Boolean  @default(false)
  lastScrapedAt DateTime?
  lastError     String?
  lastUpdated   DateTime @default(now())

  // Indexes for performance
  @@index([lastUpdated])
}

model Subscription {
  id              String   @id @default(cuid())
  userId          String
  planId          String
  status          String   @default("active")
  currentPeriodStart DateTime @default(now())
  currentPeriodEnd   DateTime
  cancelAtPeriodEnd  Boolean  @default(false)
  createdAt       DateTime @default(now())

  // Relations
  user            User     @relation("UserToSubscriptions", fields: [userId], references: [id])
  plan            UserPlan @relation("SubscriptionToPlan", fields: [planId], references: [id])

  // Indexes
  @@index([userId])
  @@index([planId])
  @@index([status])
}

// ============ AI USAGE TRACKING ============
// Needed for AI optimization and cost tracking

model AIUsageRecord {
  id                  String   @id @default(cuid())
  aiProviderId        String?  // Optional for records before AIProvider system
  userId              String
  planId              String
  requestType         String   @default("verification")
  modelUsed           String?
  requestTokens       Int      @default(0)
  responseTokens      Int      @default(0)
  cost                Float    @default(0)
  responseTime        Float    @default(0) // in seconds
  success             Boolean  @default(true)
  errorMessage        String?
  createdAt           DateTime @default(now())

  // Full relations available now
  user                User        @relation("AIUsageToUser", fields: [userId], references: [id])
  aiProvider          AIProvider? @relation("AIUsageToProvider", fields: [aiProviderId], references: [id], onDelete: SetNull)

  // Indexes for performance
  @@index([userId, createdAt])
  @@index([createdAt])
  @@index([success])
  @@index([aiProviderId])
}

// ============ PLAN USAGE ANALYTICS ============
// For revenue optimization and customer insights

model PlanUsageTracker {
  planId              String
  period              DateTime  // YYYY-MM-01 format
  totalUsers          Int       @default(0)
  totalScans          Int       @default(0)
  totalAIRequests     Int       @default(0)
  totalCost           Float     @default(0)
  revenueGenerated    Float     @default(0)
  createdAt           DateTime  @default(now())
  updatedAt           DateTime  @updatedAt

  // Composite unique key
  @@unique([planId, period])
  @@index([planId])
  @@index([period])
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}


enum SubscriptionStatus {
  FREE
  ACTIVE
  PAST_DUE
  CANCELLED
  SUSPENDED
  EXPIRED
}
